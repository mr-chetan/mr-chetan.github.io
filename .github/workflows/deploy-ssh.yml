name: Deploy to Server via SSH

on:
    # Runs on pushes targeting the main branch
    push:
        branches: ['main']
        paths-ignore:
            - 'README.md'
            - '.github/workflows/deploy.yml'
            - 'docs/**'

    # Allows you to run this workflow manually from the Actions tab
    workflow_dispatch:

# Allow only one concurrent deployment
concurrency:
    group: 'ssh-deploy'
    cancel-in-progress: false

jobs:
    build-and-deploy:
        runs-on: ubuntu-latest

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: '20'
                  cache: npm

            - name: Install dependencies
              run: npm ci

            - name: Build application
              run: npm run build

            - name: Create deployment archive
              run: |
                  cd dist
                  tar -czf ../website.tar.gz .
                  cd ..

            - name: Deploy to server via SSH
              uses: appleboy/ssh-action@v1.0.3
              with:
                  host: ${{ secrets.SSH_HOST }}
                  username: ${{ secrets.SSH_USERNAME }}
                  key: ${{ secrets.SSH_PRIVATE_KEY }}
                  port: ${{ secrets.SSH_PORT || 22 }}
                  script: |
                      # Create backup of current deployment
                      if [ -d "${{ secrets.DEPLOY_PATH }}" ]; then
                        cp -r ${{ secrets.DEPLOY_PATH }} ${{ secrets.DEPLOY_PATH }}_backup_$(date +%Y%m%d_%H%M%S)
                        # Keep only last 3 backups
                        cd $(dirname ${{ secrets.DEPLOY_PATH }})
                        ls -t | grep "_backup_" | tail -n +4 | xargs rm -rf
                      fi

                      # Create deployment directory if it doesn't exist
                      mkdir -p ${{ secrets.DEPLOY_PATH }}

                      # Clear current deployment
                      rm -rf ${{ secrets.DEPLOY_PATH }}/*

            - name: Copy files to server
              uses: appleboy/scp-action@v0.1.7
              with:
                  host: ${{ secrets.SSH_HOST }}
                  username: ${{ secrets.SSH_USERNAME }}
                  key: ${{ secrets.SSH_PRIVATE_KEY }}
                  port: ${{ secrets.SSH_PORT || 22 }}
                  source: 'website.tar.gz'
                  target: '/tmp/'

            - name: Extract and finalize deployment
              uses: appleboy/ssh-action@v1.0.3
              env:
                  RESTART_COMMAND: ${{ secrets.RESTART_COMMAND }}
              with:
                  host: ${{ secrets.SSH_HOST }}
                  username: ${{ secrets.SSH_USERNAME }}
                  key: ${{ secrets.SSH_PRIVATE_KEY }}
                  port: ${{ secrets.SSH_PORT || 22 }}
                  envs: RESTART_COMMAND
                  script: |
                      # Extract files to deployment directory
                      cd ${{ secrets.DEPLOY_PATH }}
                      tar -xzf /tmp/website.tar.gz

                      # Set proper permissions
                      chown -R ${{ secrets.WEB_USER || 'www-data' }}:${{ secrets.WEB_GROUP || 'www-data' }} ${{ secrets.DEPLOY_PATH }}
                      find ${{ secrets.DEPLOY_PATH }} -type f -exec chmod 644 {} \;
                      find ${{ secrets.DEPLOY_PATH }} -type d -exec chmod 755 {} \;

                      # Clean up temporary files
                      rm -f /tmp/website.tar.gz

                      # Restart web server if specified
                      if [ -n "$RESTART_COMMAND" ]; then
                        eval "$RESTART_COMMAND"
                      fi

                      echo "Deployment completed successfully!"

    health-check:
        needs: build-and-deploy
        runs-on: ubuntu-latest
        steps:
            - name: Health check
              run: |
                  HEALTH_CHECK_URL="${{ secrets.HEALTH_CHECK_URL }}"
                  EXPECTED_CODES="${{ secrets.HEALTH_CHECK_EXPECTED_CODES }}"
                  CUSTOM_HEADERS="${{ secrets.HEALTH_CHECK_HEADERS }}"
                  HOST_HEADER="${{ secrets.HEALTH_CHECK_HOST_HEADER }}"
                  EXTRA_OPTS="${{ secrets.HEALTH_CHECK_EXTRA_OPTS }}"

                  # Skip health check if URL is not provided
                  if [ -z "$HEALTH_CHECK_URL" ]; then
                    echo "‚è≠Ô∏è Health check skipped - HEALTH_CHECK_URL not configured"
                    exit 0
                  fi

                  echo "üîç Performing health check on: $HEALTH_CHECK_URL"

                  # Wait a moment for the server to restart
                  sleep 10

                  if [ -z "$EXPECTED_CODES" ]; then
                    EXPECTED_CODES="200 301 302"
                  fi
                  read -r -a expected_codes <<< "$EXPECTED_CODES"
                  echo "‚ÑπÔ∏è Accepting HTTP status codes: ${EXPECTED_CODES}"

                  curl_args=(
                    --location
                    --silent
                    --show-error
                    --output /dev/null
                    --write-out "%{http_code}"
                    --connect-timeout 10
                    --max-time 30
                    --retry 0
                    -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36"
                    -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8"
                    -H "Accept-Language: en-US,en;q=0.9"
                    -H "Cache-Control: no-cache"
                    -H "Pragma: no-cache"
                    --compressed
                    -e "$HEALTH_CHECK_URL"
                  )

                  if [ -n "$HOST_HEADER" ]; then
                    curl_args+=(-H "Host: $HOST_HEADER")
                  fi

                  if [ -n "$CUSTOM_HEADERS" ]; then
                    echo "‚ÑπÔ∏è Applying custom headers from HEALTH_CHECK_HEADERS"
                    while IFS= read -r header; do
                      [ -z "$header" ] && continue
                      curl_args+=(-H "$header")
                    done <<< "$CUSTOM_HEADERS"
                  fi

                  if [ -n "$EXTRA_OPTS" ]; then
                    echo "‚ÑπÔ∏è Adding custom curl options from HEALTH_CHECK_EXTRA_OPTS"
                    # shellcheck disable=SC2206
                    extra_opts=( $EXTRA_OPTS )
                    curl_args+=("${extra_opts[@]}")
                  fi

                  # Check if the website is accessible with retry logic
                  max_attempts=3
                  attempt=1

                  while [ $attempt -le $max_attempts ]; do
                    echo "üîÑ Health check attempt $attempt/$max_attempts"
                    tmp_err=$(mktemp)

                    response=$(curl "${curl_args[@]}" "$HEALTH_CHECK_URL" 2>"$tmp_err")
                    exit_code=$?

                    if [ $exit_code -eq 0 ]; then
                      if printf '%s\n' "${expected_codes[@]}" | grep -qx "$response"; then
                        echo "‚úÖ Health check passed! Website is accessible (HTTP $response)."
                        rm -f "$tmp_err"
                        exit 0
                      fi

                      echo "‚ö†Ô∏è Health check returned HTTP $response"
                    else
                      echo "‚ùå Health check failed - curl exit code $exit_code"
                      if [ -s "$tmp_err" ]; then
                        echo "--- curl error output ---"
                        cat "$tmp_err"
                        echo "--------------------------"
                      fi
                    fi

                    rm -f "$tmp_err"

                    if [ $attempt -lt $max_attempts ]; then
                      echo "‚è≥ Waiting 15 seconds before retry..."
                      sleep 15
                    fi

                    attempt=$((attempt + 1))
                  done

                  echo "‚ùå Health check failed after $max_attempts attempts"
                  exit 1

    cleanup:
        needs: health-check
        runs-on: ubuntu-latest
        steps:
            - name: Clean up old backups
              uses: appleboy/ssh-action@v1.0.3
              with:
                  host: ${{ secrets.SSH_HOST }}
                  username: ${{ secrets.SSH_USERNAME }}
                  key: ${{ secrets.SSH_PRIVATE_KEY }}
                  port: ${{ secrets.SSH_PORT || 22 }}
                  script: |
                      # Remove backups older than the last 3
                      BACKUP_DIR=$(dirname ${{ secrets.DEPLOY_PATH }})
                      cd "$BACKUP_DIR"
                      ls -t | grep "$(basename ${{ secrets.DEPLOY_PATH }})_backup_" | tail -n +4 | xargs rm -rf || true
                      echo "‚úÖ Old backups cleaned up, last 3 retained."

    notify:
        needs: cleanup
        runs-on: ubuntu-latest
        steps:
            - name: Notify deployment status
              if: always()
              run: |
                  HEALTH_CHECK_URL="${{ secrets.HEALTH_CHECK_URL }}"

                  if [ "${{ job.status }}" == "success" ]; then
                    echo "üöÄ Deployment successful!"
                    if [ -n "$HEALTH_CHECK_URL" ]; then
                      echo "Website URL: $HEALTH_CHECK_URL"
                    else
                      echo "Website deployed to server successfully!"
                    fi
                  else
                    echo "üí• Deployment failed!"
                  fi
